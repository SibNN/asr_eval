from __future__ import annotations

import copy
import json
from pathlib import Path
from typing import Any
from abc import ABC, abstractmethod
from dataclasses import fields, _is_dataclass_instance, _ATOMIC_TYPES # type: ignore

from hydra_zen.funcs import get_obj
from hydra_zen.structured_configs._implementations import DefaultBuilds

# from hydra.utils import log as _log
# _log.setLevel('FATAL')  # for get_obj messages on ImportError


class SerializableToDict(ABC):
    """
    An interface to be able to serialize an object into a json-compatible dict with
    `serialize_object` and load back with `deserialize_object`. Not needed for dataclasses.
    
    `serialize_to_dict` should return a dict that can be passed into class constructor to
    restore an equal object.
    """
    @abstractmethod
    def serialize_to_dict(self) -> dict[str, Any]: ...


def save_to_json(obj: Any, path: str | Path, indent: int = 4):
    """
    Serializes an hierarchical structure of dataclasses/lists/dicts to a json-compatible dict
    (see `serialize_object`) and then saves to a .json file. Can be loaded back with
    `load_from_json`.
    """
    path = Path(path)
    try:
        path.parent.mkdir(exist_ok=True, parents=True)
        path.write_text(json.dumps(serialize_object(obj), indent=indent))
    except KeyboardInterrupt as e:
        path.unlink(missing_ok=True)
        raise e


def load_from_json(path: str | Path) -> Any:
    """
    Loads object saved with `save_to_json`. If the .json file does not contain any
    `_target_` fields (that `serialize_object` generates for dataclasses), then
    """
    return deserialize_object(json.loads(Path(path).read_text()))


def serialize_object(obj: Any) -> Any:
    """
    Serializes an hierarchical structure of dataclasses/lists/dicts to a json-compatible dict.
    
    This includes converting dataclasses into dicts (omitting fields where the value is None and
    the default value is also None). The class full name is written to the additional `_target_`
    field to construct the object back with `deserialize_object`.
    
    Besides dataclasses, can serialize SerializableToDict objects. This is useful for custom classes
    that are not dataclasses, but we want to be able to save (to json or yaml) and load them.
    """
    result_dict: dict[str, Any]
    if isinstance(obj, SerializableToDict):
        result_dict = {'_target_': DefaultBuilds()._get_obj_path(obj.__class__)} # pyright: ignore[reportPrivateUsage]
        result_dict.update(obj.serialize_to_dict())
        return result_dict
    elif _is_dataclass_instance(obj):
        result_dict = {'_target_': DefaultBuilds()._get_obj_path(obj.__class__)} # pyright: ignore[reportPrivateUsage]
        for f in fields(obj):
            value = getattr(obj, f.name)
            if f.default is None and value is None:
                continue
            result_dict[f.name] = serialize_object(value)
        return result_dict
    elif isinstance(obj, Path):
        result_dict = {'_target_': DefaultBuilds()._get_obj_path(obj.__class__)} # pyright: ignore[reportPrivateUsage]
        result_dict['*args'] = [str(obj)]
        return result_dict
    elif type(obj) in _ATOMIC_TYPES:
        return obj
    elif type(obj) == list:
        return [serialize_object(x) for x in obj] # type: ignore
    elif type(obj) == dict:
        result_dict = {}
        for k, v in obj.items(): # type: ignore
            if not type(k) in _ATOMIC_TYPES: # type: ignore
                raise NotImplementedError(f'Can serialize only dicts with atomic keys, got {type(k)}') # type: ignore
            result_dict[k] = serialize_object(v)
        return result_dict
    else:
        raise NotImplementedError(
            'Can serialize only primitives, lists, dicts, dataclasses'
            f' and SerializableToDict, cannot serialize {obj!r}'
        )


def deserialize_object(serialized: Any, ignore_errors: bool = False) -> Any:
    """
    Deserializes object from json-compatible dict generated by `serialize_object`.
    
    If no '_target_' fields found, or cannot import the corresponding classes, does nothing.
    """
    try:
        serialized = copy.deepcopy(serialized)
        if type(serialized) in _ATOMIC_TYPES:
            return serialized
        elif type(serialized) == list:
            return [deserialize_object(x) for x in serialized] # type: ignore
        elif type(serialized) == dict:
            target = serialized.pop('_target_', None) # type: ignore
            content = {k: deserialize_object(v) for k, v in serialized.items()} # type: ignore
            if target is not None:
                assert isinstance(target, str)
                try:
                    cls = get_obj(path=target)
                except ImportError as e:
                    if not ignore_errors:
                        raise e
                    print(f'Ignoring error while deserializing: cannot import {target}')
                    content['_target_'] = target
                    return content # type: ignore
                args = content.pop('*args', []) # type: ignore
                return cls(*args, **content)
            else:
                return content # type: ignore
        pass
    except Exception as e:
        if not ignore_errors:
            raise e
        else:
            print(f'Ignoring error while deserializing: {e}')
            return serialized # type: ignore